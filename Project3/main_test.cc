os << "module " << modName<< "(clk, reset, s_valid, m_ready, data_in, m_valid, s_ready, data_out);" << endl;
os << "   parameter T=" << bits << ";" << endl;
os << "   input clk, reset, s_valid, m_ready;" << endl;
os << "   input signed [T-1:0] data_in;" << endl;
os << "   output logic signed [T-1:0] data_out;" << endl;
os << "   output logic m_valid, s_ready;" << endl;
os << "   logic signed [T-1:0] " << endl;
	for (int i=0; i < P;i++)
		if (i == P - 1)
			os << "			data_out"<< P <<";" << endl;
		else
			os << "			data_out"<< i + 1 <<"," << endl;
os << "   logic Wr_en_X, accum_src, en_f, en_check;" << endl;
os << "   logic [" << ceil(log2(N)) - 1 << ":0] Addr_X;" << endl;
os << "   logic [" << ceil(log2(M))  << ":0] " << endl;
	for (int i=0; i < P;i++)
		if (i == P - 1)
			os << "			Addr_B"<< P <<";" << endl;
		else
			os << "			Addr_B"<< i + 1 <<"," << endl;
os << "   logic unsigned [" << ceil(log2(M*N))  << ":0] Addr_W;" << endl;
os << "" << endl;
os << "" << endl;
os << "   controlpath ctrl(clk, reset, s_valid, m_ready, m_valid, s_ready, en_f, en_check, Addr_W, Addr_X, Addr_B, Wr_en_X, accum_src);" << endl;
os << "   datapath data(clk, reset, data_in, Addr_X, Addr_W, Addr_B, Wr_en_X, data_out, en_f, en_check, accum_src);" << endl;
os << "" << endl;
os << "endmodule" << endl;
os << "" << endl;
os << "module controlpath(clk, reset, s_valid, m_ready, m_valid, s_ready, en_f, en_check, Addr_W, Addr_X, Addr_B, Wr_en_X, accum_src);" << endl;
os << "" << endl;
os << "	input clk, reset, s_valid, m_ready;" << endl;
os << "	output logic Wr_en_X;" << endl;
os << "	output logic s_ready, m_valid, en_f, en_check, accum_src;" << endl;
os << "	output logic [" << ceil(log2(N)) - 1 << ":0] Addr_X;	" << endl;
os << "	output logic [" << ceil(log2(M))  << ":0] Addr_B;	" << endl;
os << "	output logic unsigned [" << ceil(log2(M*N)) << ":0] Addr_W;" << endl;
	os << "" << endl;
	os << "" << endl;
os << "	logic [" << ceil(log2(N)) - 1 << ":0] Count_X;" << endl;
os << "	logic [" << ceil(log2(M*N)) - 1 << ":0] Count_M;" << endl;
os << "	logic [2:0] state;" << endl;
	os << "" << endl;
os << "   parameter [" << ceil(log2(M*N)) - 1 << ":0]W_limit = " << M*N - 1 << ";" << endl;
os << "   parameter [" << ceil(log2(M)) - 1 << ":0]B_limit = " << M - 1 << ";" << endl;
os << "   parameter [" << ceil(log2(N)) - 1 << ":0]X_limit = " << N - 1 << ";" << endl;
os << "" << endl;
os << "	parameter [2:0] INITIAL = 3'b000, WRITE_X = 3'b011, MAC = 3'b100, OUTPUT = 3'b101;" << endl;
	os << "" << endl;
os << "" << endl;
os << "	always_comb begin" << endl;
os << "		if(s_valid==1 && s_ready==1 && state== WRITE_X) begin" << endl;
os << "			//Wr_en_M=0;" << endl;
os << "			Wr_en_X=1;" << endl;
os << "			//Wr_en_B=0;" << endl;
os << "		end" << endl;
os << "		else begin" << endl;
os << "			//Wr_en_M=0;" << endl;
os << "			Wr_en_X=0;" << endl;
os << "			//Wr_en_B=0;" << endl;
os << "		end" << endl;
os << "	end" << endl;
	os << "" << endl;
os << "	always_ff@(posedge clk) begin" << endl;
os << "		if(reset==1) begin" << endl;
os << "			Addr_W<=0;" << endl;
os << "			Addr_X<=0;" << endl;
os << "			Addr_B<=0;" << endl;
os << "			Count_M<=0;" << endl;
os << "			Count_X<=0;" << endl;
os << "			s_ready<=0;" << endl;
os << "			m_valid<=0;" << endl;
os << "			//clr_acc<=1;" << endl;
os << "			accum_src<=0;" << endl;
os << "			en_f<=0;" << endl;
os << "			state<=INITIAL;" << endl;
os << "		end" << endl;
		os << "" << endl;
os << "		case(state)" << endl;
os << "			INITIAL: begin" << endl;
os << "				Addr_W<=0;" << endl;
os << "				Addr_X<=0;" << endl;
os << "				Addr_B<=0;" << endl;
os << "				Count_M<=0;" << endl;
os << "				Count_X<=0;" << endl;
os << "				s_ready<=0;" << endl;
os << "				m_valid<=0;" << endl;
os << "				//clr_acc<=1;" << endl;
os << "			        accum_src<=1;" << endl;
os << "				state<=WRITE_X;" << endl;
os << "			end" << endl;
			os << "" << endl;
os << "			WRITE_X: begin					" << endl;
os << "				s_ready<=1;" << endl;
os << "				if(Wr_en_X==1) begin " << endl;
os << "					Addr_X<=Addr_X+1;" << endl;
os << "					if(Count_X == X_limit) begin" << endl;
os << "						state<=MAC;" << endl;
os << "						Addr_X<=0;" << endl;
os << "						Count_X<=0;" << endl;
os << "						s_ready<=0;" << endl;
os << "					end" << endl;
os << "					else " << endl;
os << "						Count_X<=Count_X+1;" << endl;
					os << "" << endl;
os << "				end		" << endl;
os << "			end" << endl;
			os << "" << endl;
os << "			MAC: begin" << endl;
os << "				m_valid<=0;" << endl;
os << "				en_check <=0;" << endl;
os << "				en_f<=1;" << endl;
os << "				//clr_acc<=0;" << endl;
os << "				accum_src<=0;" << endl;
				os << "" << endl;
os << "				if(Addr_X>= X_limit) begin" << endl;
os << "					state<=OUTPUT;" << endl;
os << "					en_check <= 1;" << endl;
os << "					Addr_X<=0;" << endl;
os << "					Addr_W<=Addr_W+1;" << endl;
os << "					Addr_B<=Addr_B+1;" << endl;
os << "				end" << endl;
os << "				else begin" << endl;
os << "					Addr_X<=Addr_X+1;" << endl;
os << "					Addr_W<=Addr_W+1;" << endl;
os << "				end" << endl;
os << "			end" << endl;
			os << "" << endl;
os << "			OUTPUT: begin" << endl;
os << "				m_valid<=1;" << endl;
os << "				en_f<=0;" << endl;
os << "				en_check <=0;" << endl;
os << "				if(m_ready==1 && m_valid==1) begin" << endl;
os << "					//clr_acc<=1;" << endl;
os << "					accum_src<=1;" << endl;
os << "					m_valid<=0;" << endl;
os << "					if( Addr_W >= W_limit) begin" << endl;
os << "						state<=INITIAL;" << endl;
os << "						Addr_W<=0;" << endl;
os << "					end" << endl;
os << "					else" << endl;
os << "						state<=MAC;" << endl;
os << "				end" << endl;
os << "				else begin" << endl;
os << "					state<=OUTPUT;" << endl;
os << "				end" << endl;
os << "			end" << endl;
os << "		endcase" << endl;
os << "	end" << endl;
os << "endmodule" << endl;
os << "" << endl;
os << "module datapath(clk, reset, data_in, Addr_X, Addr_W, Addr_B, Wr_en_X, data_out, en_f, en_check, accum_src);" << endl;
os << "    parameter T =" << bits << "; " << endl;
os << "	   input unsigned [" << ceil(log2(M*N))  << ":0] Addr_W;" << endl;
os << "	   input [" << ceil(log2(N)) - 1 << ":0] Addr_X;" << endl;
os << "	   input [" << ceil(log2(M))  << ":0] Addr_B;" << endl;
os << "    input clk, reset, Wr_en_X, accum_src, en_f, en_check;" << endl;
os << "	   input [T-1:0] data_in;" << endl;
os << "	   output signed [T-1:0] data_out;" << endl;
os << "" << endl;
os << "	logic signed [T-1:0] mem_x_out, mem_m_out, mem_b_out;" << endl;
os << "" << endl;
os << "	part2_mac M(clk, reset, mem_m_out, mem_x_out, mem_b_out, data_out, en_f, en_check, accum_src);" << endl;
	os << "" << endl;
os << "         memory #("<< bits << "," << N << "," << ceil(log2(N))  << ") mem_x(clk, data_in, mem_x_out, Addr_X, Wr_en_X);" << endl;
os << "		" << modName << "_B_rom rom_b(clk, Addr_B, mem_b_out);" << endl;
os << "		" << modName << "_W_rom rom_w(clk, Addr_W, mem_m_out);" << endl;
os << "" << endl;
os << "endmodule" << endl;
os << "" << endl;
os << "module part2_mac(clk, reset, a, b, c, f, en_f, en_check, accum_src);" << endl;
os << "   parameter T = " << bits << ";" << endl;
os << "   input                      clk, reset, accum_src, en_f, en_check;" << endl;
os << "   input signed [T-1:0]         a, b, c;" << endl;
os << "   output logic signed [T-1:0] f;" << endl;
  os << "" << endl;
os << "   // Internal connections" << endl;
os << "   logic                      clr_f, en_f;" << endl;
os << "   logic signed [T-1:0]        adderOut, adderOut_check;" << endl;
os << "" << endl;
os << "   //Combinational multiplication and addition" << endl;
os << "   always_comb begin" << endl;
os << "      adderOut = f + (a * b);" << endl;
os << "   end" << endl;
   os << "" << endl;
os << "       // Registers" << endl;
os << "   always_ff @(posedge clk) begin" << endl;
os << "      if (reset == 1) begin" << endl;
os << "         f      <= 0;" << endl;
os << "      end" << endl;
os << "      else begin" << endl;
os << "	 if (en_check == 1 && adderOut < 0)" << endl;
os << "	     f <= 0;" << endl;
os << "	else " << endl;
os << "         if (en_f) begin" << endl;
os << " 	    f <= adderOut;" << endl;
os << "	 end" << endl;
os << "	 else if (accum_src) begin" << endl;
os << "	   f <= c;" << endl;
os << "	 end" << endl;
    os << "" << endl;
os << "      end" << endl;
os << "   end" << endl;
   os << "" << endl;
os << "endmodule " << endl;
os << "" << endl;
os << "" << endl;
os << "" << endl;
os << "module memory(clk, data_in, data_out, addr, wr_en);" << endl;
   os << "" << endl;
os << "   parameter WIDTH=16, SIZE=64, LOGSIZE=6;" << endl;
os << "   input [WIDTH-1:0] data_in;" << endl;
os << "   output logic [WIDTH-1:0] data_out;" << endl;
os << "   input [LOGSIZE-1:0]      addr;" << endl;
os << "   input                    clk, wr_en;" << endl;
   os << "" << endl;
os << "   logic [SIZE-1:0][WIDTH-1:0] mem;" << endl;
   os << "" << endl;
os << "   always_ff @(posedge clk) begin" << endl;
os << "      data_out <= mem[addr];" << endl;
os << "	  if (wr_en)" << endl;
os << "	    mem[addr] <= data_in;" << endl;
os << "   end" << endl;
os << "endmodule" << endl;
os << "" << endl;  
     

   // At some point you will want to generate a ROM with values from the pre-stored constant values.
   // Here is code that demonstrates how to do this for the simple case where you want to put all of
   // the matrix values W in one ROM, and all of the bias values B into another ROM. (This is probably)
   // what you will need for P=1, but you will want to change this for P>1.


   // Check there are enough values in the constant file.